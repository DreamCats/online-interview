# 闭包

## 问题

### 变量作用域

作用域：**全局变量和局部变量**，则**函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量**

### 如何获取内部局部变量

```javascript
function f1(){
  var n=999;
  function f2(){
    console.log(n); // 999
  }
}
```

数 f2 就被包括在函数 f1 内部，这时 f1 内部的所有局部变量，对 f2 都是可见的。但是反过来就不行，f2 内部的局部变量，对 f1 就是不可见的。这就是 Javascript 语言特有的 "链式作用域" 结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。既然 f2 可以读取 f1 中的局部变量，那么只要把 f2 作为返回值，我们不就可以在 f1 外部读取它的内部变量了吗！

```javascript
function a(){
  var n = 0;
  function inc(){
    n++; 
    console.log(n);
  }
  return inc; // 而返回的是内部函数
}
var c = a();
c();  //控制台输出1
c();  //控制台输出2
```

js的每个函数都是一个个小黑屋，它可以获取外界信息，但是外界却无法直接看到里面的内容。

将变量 n 放进小黑屋里，除了 inc 函数之外，没有其他办法能接触到变量 n，而且在函数 a 外定义同名的变量 n 也是互不影响的，这就是所谓的增强“封装性”。

而之所以要用 return 返回函数标识 inc，是因为在 a 函数外部无法直接调用 inc 函数，所以 return inc 与外部联系起来

## 概念

上面代码中的 f2 函数，就是闭包。说白了，**闭包就是能够读取其他函数内部变量的函数**，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。

## 用途

- 可以读取函数内部的变量
- 让这些变量的值始终保存在内存中，不会在外层调用后被自动清除：原因就在于 f1 是 f2 的父函数，而 f2 被赋给了一个全局变量，这导致 f2 始终在内存中，而 f2 的存在依赖于 f1，因此 f1 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。

## 优缺点

### 优点

- 避免全局变量的污染；
- 能够读取函数内部的变量；
- 在内存中维护一个变量

### 缺点

- 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
- 操作不当容易浪费内存，造成内存泄漏

