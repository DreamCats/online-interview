## prototype

> 在ES6之前，js中是没有Class的概念的（ES6中的类也是语法糖，本质还是基于原型），为了实现实例对象的属性和方法共享，就给function设计了一个prototype的概念。 当我们调用一个对象的属性时，如果对象没有该属性，JavaScript 解释器就会从对象的原型对象上去找该属性，如果原型上也没有该属性，那就去找原型的原型，直到最后返回null为止，null没有原型。这种属性查找的方式被称为原型链（prototype chain）。（像不像JVM的类加载器...）


**原型也是一个对象，通过原型可以实现对象的属性继承，函数有原型**，函数有一个属性叫prototype，函数的这个原型指向一个对象，这个对象叫原型对象。这个原型对象有一个constructor属性，指向这个函数本身。

一个实例化对象，没有prototype属性

## 看例子

```javascript
var TestPrototype = function () {
  this.propA = 1;
  this.methodA = function() {
    return this.propA;
  }
}
TestPrototype.prototype = {
  methodB: function() {
    return this.propA;
  }
}
var objA = new TestPrototype();
objA.methodA() // 1
objA.methodB() // 1
```

当我们直接在控制台输出objA时，返回：
![js的prototype-1-QBSGBT](https://cdn.jsdelivr.net/gh/DreamCats/imgs@main/uPic/js的prototype-1-QBSGBT.jpg)

可以看出，该实例对象有3个属性，其中并没有methodB。这就是方法在构造函数内声明和在原型上声明的区别之一。不过，展开**proto**展开，发现methodB在图中的位置。

![js的prototype-2-oDHSvy](https://cdn.jsdelivr.net/gh/DreamCats/imgs@main/uPic/js的prototype-2-oDHSvy.jpg)

但，这样写有什么好处呢？

再看一个例子：

```js
var objB = new TestPrototype();
```
![js的prototype-3-gVjAQc](https://cdn.jsdelivr.net/gh/DreamCats/imgs@main/uPic/js的prototype-3-gVjAQc.jpg)

看似和objA长的很像，其实他们并不相等的，比如

![js的prototype-4-ujhUL0](https://cdn.jsdelivr.net/gh/DreamCats/imgs@main/uPic/js的prototype-4-ujhUL0.jpg)

可从图中可以看出，methodA返回的是false，而methodB返回的是true

重点来了，把方法写在构造函数的内部，无疑是增加了构造函数初始化一个对象的成本（**内存占用，因为两个实例对象就创建了两个一样的方法methodA**），把方法写在prototype属性上就可以有效的减少了其成本（他们都指向了同一个methodB）。因此，这种重复性的方法就可以写在原型中，当你的构造函数有相当多的方法，并且实例化非常多时，提升是非常大的。

再举个例子：

当我们创建一个对象后，就可以通过“点”方法名的方式调用一些并不是我们手写的方法了，如obj.toString()

```js
obj.toString === Object.prototype.toString
// true
```
其实我们调用的是Object.prototype.toString。
