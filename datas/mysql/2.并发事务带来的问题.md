> 对于这个问题，建议掌握流程。

# 问题产生

不采取任何隔离级别

## 脏读

第一个事务首先读取变量为 50，接着准备更新为 100 的时，并未提交，第二个事务已经读取为 100，此时第一个事务做了回滚。最终第二个事务读取的变量和数据库的不一样。​

核心关键词：**回滚，未提交读**​

t1:50 to100 -> rollback 50
t2: get 100 -> commit 100

## 丢弃修改

T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，**T2 的修改覆盖了 T1 的修改** 。例如：事务 1 读取某表中的数据 A=50，事务 2 也读取 A=50，事务 1 修改 A=A+50，事务 2 也修改 A=A+50，最终结果 A=100，事务 1 的修改被丢失。
​

核心关键词：**覆盖**

t1: 50 to100 commit 100(t2)
t2: 50 to 100 commit 100(t2)

## 不可重复读

T2 读取一个数据，T1 对该数据做了修改并提交。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

核心关键词：**两次读取的结果不同**

t1: 50 to 100 commit 100
t2: get 50 get 100 commit 100 (两次 get res 不一样)

## 幻读

T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和第一次读取的结果不同。（和不可重复读的区别：一个是变量变化，一个是范围变化）

核心关键词：**两次读取范围变化**

t1: get (50) get(50,100) commit (50,100) (两次范围不一样)
t2: (50) to (50,100) commit

# 隔离级别

首先，MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重复读）**

其次，这里需要注意的是 ：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 **REPEATABLE-READ（可重复读）**事务隔离级别下使用的是**Next-Key Lock 锁算法**，因此可以**避免幻读**的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说 InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**已经可以完全保证**事务的隔离性要求**，即达到了 SQL 标准的** SERIALIZABLE(可串行化)隔离级别**。
​

因为**隔离级别越低**，事务请求的**锁越少**，所以大部分数据库系统的隔离级别都是 **READ-COMMITTED(读取提交内容)**，但是你要知道的是 InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重复读）**并不会有任何性能损失 。

## 未提交读

事务中发生了修改，即使没有提交，其他事务也是可见的，比如对于一个数 A 原来 50 修改为 100，但是我还没有提交修改，另一个事务看到这个修改，而这个时候原事务发生了回滚，这时候 A 还是 50，但是另一个事务看到的 A 是 100.
​

该隔离级别，**可能会导致脏读、幻读或不可重复读。**

## 提交读

对于一个事务从开始直到提交之前，所做的任**何修改是其他事务不可见**的，只能读取到**已经提交**的数据，举例就是对于一个数 A 原来是 50，然后提交修改成 100，这个时候另一个事务在 A 提交修改之前，读取的 A 是 50，刚读取完，A 就被修改成 100，这**个时候另一个事务再进行读取发现 A 就突然变成 100 了；（两次读取出了问题，即不可重复读）**

**可以阻止脏读，但是幻读或不可重复读仍有可能发生。**

## 可重复读

就是对一个记录读取多次的记录是相同的，在同一个事务内的查询都是**事务开始时刻一致**的；

**可以阻止脏读和不可重复读，但幻读仍有可能发生**。

## 串行读

在并发情况下，和串行化的读取的结果是一致的，没有什么不同，比如不会发生脏读和幻读；

**该级别可以防止脏读、不可重复读以及幻读。**
