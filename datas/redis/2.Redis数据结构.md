## String

String 数据结构是简单的 key-value 类型，value 其实不仅可以是 String，也可以是数字。 常规 key-value 缓存应用； **常规计数：微博数，粉丝数**等。

## Hash

Hash 是一个 string 类型的 ﬁeld 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 Hash 数据结构来**存储用户信息，商品信息**等等。

简单说一下结构

- 字典被广泛用于实现 Redis 的各种功能，其中包括数据库和哈希键。
- Redis 中的字典使用哈希表作为底层结构实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行 rehash 时使用。
- Redis 使用 MurmurHash2 算法来计算键的哈希值。
- 哈希表使用链地址法来解决键冲突。

注意：这里和 Java 的 HashMap 不同的 rehash 过程

1. Redis 的 rehash 过程是扩展和收缩，而且还是渐进式的 rehash
2. Redis 的字典有两个哈希表 ht[0]和 ht[1]
3. 为字典的 ht[1]哈希表分配空间，如果执行的是扩展操作，那么 ht[1]的大小为第一个大于等于 ht[0].used \*2 的 2^n；如果执行的是收缩操作，那么 ht[1]的大小第一个大于等于 ht[0].used 的 2^n。（举个例子，ht[0]的长度为 10，那么扩展就是 2^5 的 32，如果是压缩的话 2^4=16）
4. 如果 ht[0]的键值非常多的话，一次性转移过去，是一个非常耗时的操作哦，因此并非一次性，采取渐进式 rehash 转移。

## List

list 就是链表，Redis list 的应用场景非常多，也是 Redis 最重要的数据结构之一，比如**微博的关注列表，粉丝列表， 消息列表**等功能都可以用 Redis 的 list 结构来实现。

Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。

另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。

## Set

set 对外提供的功能与 list 类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。

当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在 一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。

比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常 方便的实现如**共同关注、共同粉丝、共同喜好**等功能。这个过程也就是求交集的过程，具体命令如下：`sinterstore key1 key2 key3`将交集存在 key1 内

## Zset

和 set 相比，sorted set 增加了一个**权重参数 score**，使得集合中的元素能够按 score 进行**有序**排列。

举例： 在直播系统中，实时排行信息包含直播间在线用户列表，各种**礼物排行榜**，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 SortedSet 结构进行存储。

跳跃表，暂时先放一个链接[https://zhuanlan.zhihu.com/p/53975333](https://zhuanlan.zhihu.com/p/53975333)

- 简单来说跳跃表是一种有序数据结构，它通过在**每个节点中维持多个指向其他节点的指针**，从而达到快速访问节点的目的。
- 跳跃表平均 O(longN)，最坏 O(N)复杂度的节点查找
- 跳跃表有个层的概念：层带有两个属性：**前进指针和跨度**，前进指针用于**访问位于表尾方向的其他节点**，而跨度则记录了**前进指针所指向节点和当前节点的距离**。一般情况下，层越多，查找效率越高。
