# Redis 常见的三种缓存策略

> 不是我在料理植物，而是植物在料理我。
> 培土、拔草、浇水、晒阳光
> 不是别的，是我的心。

## 背景

> 不会真有人不会使用 redis 充当缓存吧？

所以，本次学习一下关于 "缓存+数据库"模型读写的一致性问题：

1. 缓存中是否有可能被写入脏数据；
2. 策略的读写性能如何；
3. 是否存在缓存命中率下降的。

## Cache Aside（旁路缓存）策略

### 更新数据库，更新缓存

一般情况下，当我们变更数据库中的数据，首先思路是更新数据库，最后修改 redis 的缓存来保证一致性，这是最容易想到的思路。

所以，抽象出来，其实是：

1. 写策略：先更新数据库，再更新缓存；
2. 读策略：读缓存，缓存缺失时查数据库并回写缓存；

![](https://imgs.heiye.site/byte/1646643380261.png)

一般情况下，这种思路不会什么问题，但在一定的并发下，可能会出现缓存不一致的情况，如下面的例子：

![](https://imgs.heiye.site/byte/1646645225181.png)

有两个请求，分别为请求 1 和请求 2：

1. 请求 1：更新数据库 20，更新缓存；
2. 请求 2：更新数据库 21，更新缓存；
3. 如上图：数据库中的结果是 21，但是缓存中的数据是 20，这是不一致的。

原因：因为变更数据库和变更缓存是两个独立的操作，而我们并没有对操作做任何的并发控制。那么当两个线程并发更新它们的时候，就会因为写入顺序的不同造成数据的不一致。

### 删除缓存，更新数据库

如果写入缓存的顺序可能不一样，那就先删除缓存，再更新数据库，那么这样看看有什么问题。

1. 写策略：先删除缓存，再更新数据库；
2. 读策略：读缓存，缓存缺失时查找数据库并回写缓存；

那么，看极端情况：

![](https://imgs.heiye.site/byte/1646646302432.png)

依然是两个请求，分别为请求 1 和请求 2：

1. 请求 1：删除缓存，更新数据库
2. 请求 2：读取缓存，缓存缺失时查找数据库里的数据并回写缓存
3. 如上图：数据库中的结果是 21，但是缓存中的数据是 20，这是不一致的。

上一个思路的原因是差不多的。

解决这样的问题，可以通过 "延迟双删" 策略（更新后再次删除缓存）解决，但是这种策略对写性能影响较大，通常很少使用；

```c
redis.delkey(x)
db.update(x)
sleep(n)
redis.delkey(x)
```

### 更新数据库，再删除缓存

1. 写策略：先更新数据库，再删除缓存；
2. 读策略：读缓存，缓存缺失时查数据库并回写缓存；

![](https://imgs.heiye.site/byte/1646646737438.png)

这个策略就是使用缓存最常见的策略，Cache Aside 策略（也叫旁路缓存策略）；

但是，当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。如果业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：

1. 在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；
2. 另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快地过期，对业务的影响也是可以接受。

以上三种思路中写数据库和写缓存都是分离的，那就有可能存在先写数据库成功后写缓存失败或先写缓存成功后写数据库失败的情况，这种情况同样会造成数据库和缓存不一致，这时可以把写操作通过消息中间件进行重试。

![](https://imgs.heiye.site/byte/1646648167496.png)

## Read/Write Through（同步直写）策略

这个策略的核心原则是用户只与缓存模块打交道，由缓存模块跟具体的缓存实现及数据库通信，写入或者读取数据。

- Write Through 策略：写请求直接发到缓存模块，缓存模块先查询要写入的数据在缓存中是否已经存在：

  - 如果已经存在：则使用事务机制保证写入缓存和写数据库具有原子性；
  - 如果不存在：则直接写入数据库

- Read Through 策略：跟 Cache Aside 类似，缓存模块先查询缓存中数据是否存在：
  - 如果存在：则直接返回
  - 如果不存在：则从数据库中同步回写数据到缓存中，然后返回；

优点：可以保证数据一致性，读性能高；
缺点：同步写对写性能有比较大的影响，不适合写多的场景；

这种策略涉及到缓存模块的开发，针对只用 Redis+DB 场景也可以由 Client 实现缓存模块的功能，通过事务来保证 Redis 和 DB 的一致性；

## Write Behind（异步写回）策略

Write-Behind 和 Write-Through 在用户与缓存模块的交互特别相似，不同点在于 Write-Through 会把数据立即写入数据库中，而 Write-Behind 只写入缓存并会把缓存标记为脏的，在一段时间之后（或是被其他方式触发）再把数据一起写入数据库；

数据库写操作可以用不同的方式完成：

1. 其中一个方式就是收集所有的写操作并在某一时间点（比如数据库负载低的时候）批量写入；
2. 另一种方式就是合并几个写操作成为一个小批次操作，接着缓存收集写操作（比如 5 个）一起批量写入；

优点：异步写操作极大的降低了请求延迟并减轻了数据库的负担，大大提升写性能；
缺点：因为缓存一般使用内存，而内存是非持久化的，所以一旦缓存机器掉电，就会造成原本缓存中的脏块儿数据丢失，造成数据不一致；

## 小结

1. Cache Aside 是在使用分布式缓存时最常用的策略，可以在实际工作中直接拿来使用；
2. Read/Write Through 和 Write Back 策略需要缓存组件的支持，所以比较适合在实现本地缓存组件的时候使用；
3. Write Back 策略是计算机体系结构中的策略，不过写入策略中的只写缓存，异步写入后端存储的策略倒是有很多的应用场景。
