# Redis 主从复制原理

> 但愿每一个人都像星星一样安详而从容地，不断沿着既定的目标走完自己的路程。
> 在现在的中间件架构中，无论是 MySQL、Redis 还是 RocketMQ 中的 broker 组件等，存在主从架构，那么有了为什么会有主从架构？

## 背景

假如，你现在有一个项目，需要使用到缓存，在体量不大的时候，采取了如下的架构：

![](https://imgs.heiye.site/byte/1645433994348.png)

从图上看，属实非常简单，一个 redis 单机版就可以满足读写。

假如有一天，读请求开始增多的情况下，redis 承受的压力剧增，需要适当的调整一下架构，比如：我们可以专门提供一读请求的 Redis 服务？类似于下面的结构：

![](https://imgs.heiye.site/byte/1645434517308.png)

但开始思考了，如何将 master 的数据同步到 slave 呢？又是如何保证数据一致性呢？

我们来回顾一下 MySQL 的主从同步原理是什么？

简单来讲，主库（master）将变更写**binlog** 日志，然后从库（slave）连接到主库之后，从库有一个**IO 线程** ，将主库的 binlog 日志**拷贝到自己本地** ，写入一个**中继日志**中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。

MySQL 需要借助一个中间文件来同步，那么 Redis 是否可以借助某个文件来同步？

众所周知：Redis 的持久化的方式有 RDB 和 AOF 两种方式，这两个方式可以作为介质来同步。

![](https://imgs.heiye.site/byte/1645436458938.png)

简单说明一下 RDB 和 AOF 的特点，不再详细的赘述了：

- RDB：只持久化**某一时刻的数据快照到磁盘上**（创建一个子进程来做）
- AOF：**每一次写操作都持久到磁盘**（主线程写内存，根据策略可以配置由主线程还是子线程进行数据持久化）

它们的区别除了上面讲到的，还有以下特点：

1. RDB 采用二进制 + 数据压缩的方式写磁盘，这样文件体积小，数据恢复速度也快。
2. AOF 记录的是每一次写命令，数据最全，但文件体积大，数据恢复速度慢。

如果让你来选择持久化方案，你可以这样选择：

1. 如果你的业务对于数据丢失不敏感，采用 RDB 方案持久化数据。
2. 如果你的业务对数据完整性要求比较高，采用 AOF 方案持久化数据。

假设你的业务对 Redis 数据完整性要求比较高，选择了 AOF 方案，那此时你又会遇到这些问题：

1. AOF 记录每一次写操作，随着时间增长，AOF 文件体积会越来越大。
2. 这么大的 AOF 文件，在数据恢复时变得非常慢。

根据以上特点：**于主从同步来说，主从刚刚连接的时候，进行全量同步（RDB）；全同步结束后，进行增量同步(AOF)。**

## 主从复制的工作原理

其实就是一句话：主从刚刚连接的时候，进行**全量同步**（RDB）；全同步结束后，进行**增量同步**(AOF)。

主从复制完整的工作流程分为以下**三个阶段**。每一段都有自己的内部工作流程，那么我们会对这三个过程进行谈论。

1. 建立连接过程：这个过程就是 slave 跟 master 连接的过程（同步前，不得连接？）
2. 数据同步过程：是 master 给 slave 同步数据的过程（连接好了，不得赶紧同步？）
3. 命令传播过程：是反复同步数据（数据无时无刻在变化，持续同步）

所以，简单来讲，三个阶段的图示：

![](https://imgs.heiye.site/byte/1645436941549.png)

### 第一阶段

既然第一阶段是连接，那么你就会想，那该怎么连接呢？连接需要什么条件:双方的 ip 、port 和建立使用的协议等。

1. 设置 master 的地址和端口，保存 master 的信息
2. 建立 socket 连接
3. 持续发送 ping 命令
4. 身份验证
5. 发送 slave 端口信息

在建立连接的过程中，从节点会保存 master 的地址和端口、主节点 master 保存从节点 slave 的端口。

### 第二阶段

![](https://imgs.heiye.site/byte/1645447186400.png)

1. 发送指令：psync2
2. 执行 bgsave
3. 创建缓冲区
4. 生成 RDB 文件，通过 socket 发送给 slave
5. 接收 RDB，执行 RDB 恢复过程
6. 发送命令告知 RDB 恢复完成
7. 发送复制缓冲区信息
8. 接收信息，执行 bgrewriteaof，恢复数据

注意：从节点第一次连接主节点时，先会执行一次**全量复制**这次的全量复制是无法避免的。 全量复制执行完成后，主节点就会发送复制**积压缓冲区的数据**，然后从节点就会执行 **bgrewriteaof** 恢复数据，这也就是部分复制。 在这个阶段提到了三个新点，全量复制、部分复制、复制缓冲积压区。

### 第三方阶段

当 master 数据库被修改后，主从服务器的数据不一致后，此时就会让主从数据同步到一致，这个过程称之为命令传播。 master 会将接收到的数据变更命令发送给 slave，slave 接收命令后执行命令，让主从数据达到一致。 命令传播阶段的**部分复制**：

- 在命令传播阶段出现断网的情况，或者网络抖动时会导致连接断开（connection lost）
- 这个时候主节点 master 还是会继续往 replbackbuffer（复制缓冲积压区）写数据
- 从节点会继续尝试连接主机（connect to master）
- 当从节点把自己的 runid 和复制偏移量发送给主节点，并且执行 pysnc 命令同步
- 如果 master 判断偏移量是在复制缓冲区范围内，就会返回 continue 命令。并且发送复制缓冲区的数据给从节点。
- 从节点接收数据执行 bgrewriteaof，恢复数据

### 心跳机制

在命令传播阶段是，主节点与从节点之间一直都需要进行信息互换，使用**心跳机制进行维护**，实现主节点和从节点连接保持在线。

- master 心跳

  - 指令：ping
  - 默认 10 秒进行一次，是由参数 repl-ping-slave-repiod 决定的
  - 主要做的事情就是判断从节点是否在线
  - 可以使用 info replication 来查看从节点租后一次连接事件的间隔，lag 为 0 或者为 1 就是正常状态。

- slave 心跳任务
  - 指令：replication ack {offset}
  - 每秒执行一次
  - 主要做的事情是给**主节点发送自己的复制偏移量**，从主节点获取到最新的数据变更命令，还做一件事就是判断**主节点是否在线**。

注意：主节点为保障数据稳定性，**当从节点挂掉的数量或者延迟过高时，将会拒绝所有信息同步**。
