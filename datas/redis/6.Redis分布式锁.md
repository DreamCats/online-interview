# 分布式锁

> 毕竟判断和绑定座位（或者下单）非原子性，为了降低锁的粒度，可以将判断和绑定座位锁在一个事务里。集群：Redisson

- Key 为 xx\_座位号，过期时间为随机 1-5s（用 setex 的命令，该命令是 key 和过期时间是原子性的）
- 每次先 Redis 中判断该 key 存在不存在，如果存在，要么阻塞，要么就返回给用户，座位已被选择。
- 如果不存在，先上锁，然后再判断和绑定座位（或者下单）。其实这里有个隐藏的问题。如果绑定座位非常耗时，超过了过期时间 1-5s，就凉凉了。其实这里设置过期时间，就是防止一直因为某种原因阻塞而不释放锁
- 前三步，少了个签证 value，如果不设置，那么当锁过期了，业务逻辑才走完，准备删除的时候，B 客户端获取到了该锁，但是 A 把 B 的 key 锁删除了，然而 B 还不知道。
- 因此，要解决这个问题，可以设置 value 签证，结束的时候判断一次，该 value 是不是自己的 value，这样就不会误删。

## RedLock 算法流程

首先有这样的问题：

1. 客户端 A 从 Master 上获取锁。
2. 在锁未被复制到某 Slave 节点的时候，Master 节点 Down 掉了。
3. 某 Slave 节点成为新的 Master。
4. 客户端 B 可从新 Master 上获取锁。

假设有 5 个实例

1. 比如过期时间为 TTL：10min
2. 记录当前时间：比如 T1 = 12:00
3. 客户端分别向 5 个实例获取锁，比如申请锁的时间依次为：12:01...12:05,最后获取实例的锁为 T2:12:05（获取锁的超时时间要远远小于过期时间，防止死等。）
4. 如果获取锁的实例大于 3 个（过半机制），那么就相当于获取到锁了，该锁的真正的有效时间为 TTL-(T2-T1) = 5min
5. 如果客户端由于某些原因获取锁失败，便会开始解锁所有 redis 实例；因为可能已经获取了小于 3 个锁，必须释放，否则影响其他 client 获取锁

[https://juejin.im/post/5cc165816fb9a03202221dd5](https://juejin.im/post/5cc165816fb9a03202221dd5)

## zk 实现分布式锁

[补充-Zookeeper 锁的实现](https://juejin.im/post/5c01532ef265da61362232ed)
