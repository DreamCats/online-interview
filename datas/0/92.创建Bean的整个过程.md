## 创建Bean的整个过程
1. 首先finishBeanFactoryInitialization->preInstantiateSingletons->getBean->doGetBean;
2. 在doGetBean中，transformedBeanName:主要负责判断一下有木有别名；getSingleton：从一级缓存singletonObjects拿bean，在getSingleton方法中，有一个判断条件就是isSingletonCurrentlyInCreation，判断为false，因为他是第一次进来，并且还没有正在创建该bean；dependsOn：依赖，暂时先不说他。
3. 再来一次getSingleton：再一次的从singketonObjects缓存拿，依然没有的。接着有个重点beforeSingletonCreation：它把bean添加到临时的singletonsCurrentlyInCreation，这就意味着，下次再碰见它，那可就是true了。接着singletonFactory.getObject()，这里getObject调用的是传递的接口createBean方法。
4. 在createBean方法中：有个doCreateBean->createBeanInstance方法：它就是直接实例化，实际上构造器有反应了（区分JVM创建对象和Spring创建对象），但是没有赋值（初始化）；earlySingletonExposure：提前暴漏该bean。但要知道三个变量，为什么他是true：isSingleton()，是否单例，那肯定是哦；（这里解释了这里是单例才能提前曝漏，意味着才能存三级缓存）allowCircularReferences，默认变量为true，写死了；isSingletonCurrentlyInCreation，这里可就为true了，因为步骤3，已经将它设置为true了。那么会进来这个方法：addSingletonFactory
5. addSingletonFactory在这个方法中：将该bean放入到三级缓存singletonFactories中。（解决循环依赖）
6. 接下来，就是它了，populateBean：实际上就是属性赋值。（如果这里要有A依赖B，又发现三级缓存中没有B，那么它就会再次执行一次（递归开始）getBean->doGetBean->createBeanInstance(把B给实例化一下)，同样的道理，这里会将B也会放入三级缓存中，B开始populateBean，那么它发现B依赖A，此时三级缓存中有A(精髓，牛逼)，然后把A放到二级缓存中，同时从三级缓存中移除，接着得到A之后直接赋值，最后完成了初始化，然后来到addSingleton，将B仍到了一级缓存，同时将B从三级缓存仍出去）返回B，递归结束，得到B之后将B的赋值给A了。
7. 最后将二级缓存的A删除，仍到一级缓存中。