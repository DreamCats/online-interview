## 垃圾回收算法

垃圾回收算法：

1. **标记-清除**

该算法分为“标记”和“清除”阶段：首先**标记出所有需要回收的对象**，在标记完成后**统一回收所有被标记的对象**。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：

- **效率问题**
- **空间问题（标记清除后会产生大量不连续的碎片）**

2. **标记-整理**

根据**老年代的特点**提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是**让所有存活的对象向一端移动**，然后直接清理掉端边界以外的内存。（老年代一般存入的是大对象，时间比较久的对象）

3. **复制**

为了**解决效率**问题，“复制”收集算法出现了。它可以将**内存分为大小相同的两块**，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。**这样就使每次的内存回收都是对内存区间的一半进行回收**。（堆的年轻代又分为Eden、s0和s1）

4. **分代**

**比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**

一般情况：

- 大多数情况下，**对象在新生代中 eden 区分配**。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.
- **大对象直接进入老年代**，大对象就是需要**大量连续内存空间的对象**（比如：字符串、数组）。频繁复制降低性能。
- 如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1. 对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被**晋升到老年代**中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。