# 垃圾回收器

面试官：给我讲讲垃圾收集器吧

我：当然没问题，有一张有趣的图

![垃圾回收器-AXT6Jn](https://cdn.jsdelivr.net/gh/DreamCats/imgs@main/uPic/垃圾回收器-AXT6Jn.png)

小插曲：咱们知道，堆分为新生代和老年代，那么从这张图可以看出，新生代有 Serial、ParNew 和 Parallel Scavenge 而老年代自然也有 Serial Old 和 Parallel Old，新生代和老年代都有串并行收集器，能互相搭配，但看 CMS 就很特殊，它是老年代的收集器，能从图中可以看出来，它不稳定呀，居然用 Serial Old 当备胎，而且为了能搭配 CMS 的并行垃圾收集器，就给它造了一个 ParNew，哈哈哈（开个玩笑）。G1 暂且不说，横跨新生和老年。在它这一块不分家，一把抓。

我就简单说一下串并行垃圾收集器，太古老了，面试官也不想听。

你像 Serial 和 ParNew 呀，其实在 STW 的时候，一个是**单线程**，一个是**多线程**回收垃圾。而 ParNew 和 Parallel Scavenge 的区别仅仅是**吞吐量**，后者重在吞吐量上（高效率利用 CPU）。所以，**Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。而 ParNew 是在 Server 模式下的虚拟机的首要选择之一。以上垃圾收集器新生代采用复制，而老年代采用标记-整理。**

**CMS 垃圾收集器**：

**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。**

**CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**

从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- 初始标记：暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- 并发标记：同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- 重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- 并发清除：开启用户线程，同时 GC 线程开始对为标记的区域做清扫。

从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**

因此，为了解决以上缺点，**G1**就出现了：

- **将整个 Java 堆划分为多个大小相等的独立区域（Region）**，虽然还保留新生代和老年代的概念，但**新生代和老年代不再是物理隔离的了，而都是一部分 Region（不需要连续）的集合**

- 并行与并发： G1 能充分利用 **CPU、多核**环境下的硬件优势，使用多个 CPU 来缩短 Stop-The-World 停顿时间。
- 分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- 空间整合：G1 从整体来看是基于**“标记整理”**算法实现的收集器；从局部上来看是基于**“复制”算法**实现的。
- 可预测停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型。G1 跟踪**各个 Region 里面的垃圾堆积的价值大小**（回收所获得的空间大小以及回收所需要时间的经验值），在后台维护一个**优先列表**，每次根据允许的收集时间，**优先回收价值最大的 Region**。

**G1 的跨代引用**：

在 G1 收集器中，**Region 之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用**，虚拟机都是使用**Remembered Set（RS）**来避免全堆扫描的。**G1 中每个 Region 都有一个与之对应的 RS**，虚拟机发现程序**对 Reference 类型的数据进行写操作**时，会产生**一个 Write Barrier 暂时中断操作**，**检查 Reference 引用的对象是否处于不同的 Region 之间**（在分代的例子中就是检查是否老年代中的对象引用了新生代中方的对象）如果是，便**通过 CardTable（每个 Region 块又细分了 2000 多个卡表，记录一波我引用了哪个对象）把相关引用信息记录到被引用对象所属的 Region 的 RS 之中**。当进行内存回收时，**在 GC 根节点的枚举范围中加入 RS 即可保证不对全堆扫描，也不会又遗漏**。

当然 G1 有也大致的四个过程：

- 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改**TAMS（Nest Top Mark Start）**的值，让下一阶段用户程序并发运行时，能在正确可以的 Region 中创建对象，此阶段需要**停顿线程**，但耗时很短。
- 并发标记：从 GC Root 开始对堆中对象进行**可达性分析**，找到存活对象，此阶段耗时较长，但**可与用户程序并发执行**。
- 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在**线程的 Remembered Set Logs**里面，最终标记阶段需要**把 Remembered Set Logs 的数据合并到 Remembered Set 中**，这阶段需要**停顿线程**，但是**可并行执行**。
- 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

在这里，简单做一个 CMS 和 G1 的比较：

1. CMS 收集器是**获取最短回收停顿时间**为目标的收集器，因为 CMS 工作时，GC 工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的（只有初始标记和重新标记会 STW）。但**是 CMS 收集器对 CPU 资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会占用 CPU 资源而导致引用程序变慢，总吞吐量下降**。
2. CMS 仅作用于老年代，是基于**标记清除算法**，所以清理的过程中**会有大量的空间碎片**。
3. CMS 收集器**无法处理浮动垃圾**，**由于 CMS 并发清理阶段用户线程还在运行**，伴随程序的运行自然会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS 无法在本次收集中处理它们，只好留在下一次 GC 时将其清理掉。
4. G1 是一款面向服务端应用的垃圾收集器，**适用于多核处理器、大内存容量的服务端系统**。G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU 或核心来缩短 STW 的停顿时间，它满足短时间停顿的同时达到一个高的吞吐量。
5. **从 JDK 9 开始，G1 成为默认的垃圾回收器**。当应用有以下任何一种特性时非常适合用 G1：Full GC 持续时间太长或者太频繁；对象的创建速率和存活率变动很大；应用不希望停顿时间长(长于 0.5s 甚至 1s)。
6. G1 将空间划分成很多块（Region），然后他们各自进行回收。堆比较大的时候可以采用，采用复制算法，碎片化问题不严重。整体上看属于标记整理算法,局部(region 之间)属于复制算法。
7. G1 需要记忆集 (具体来说是卡表)来记录新生代和老年代之间的引用关系，这种数据结构在 G1 中需要占用大量的内存，可能达到整个堆内存容量的 20% 甚至更多。而且 **G1 中维护记忆集的成本较高**，带来了更高的执行负载，影响效率。**所以 CMS 在小内存应用上的表现要优于 G1，而大内存应用上 G1 更有优势，大小内存的界限是 6GB 到 8GB**。
