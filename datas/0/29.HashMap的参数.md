## HashMap的参数

- 为什么容量要是 2 的整数次幂？

因为获取 key 在数组中对应的下标是通过 key 的哈希值与数组长度 -1 进行与运算，如：tab[i = (n - 1) & hash]

1. n 为 2 的整数次幂，这样 n-1 后之前为 1 的位后面全是 1，这样就能保证 (n-1) & hash 后相应的位数既可能是 0 又可能是 1，这取决于 hash 的值，这样能保证散列的均匀，同时与运算效率高

2. 如果 n 不是 2 的整数次幂，会造成更多的 hash 冲突

> 举个例子：如 16：10000, 16-1=15：1111, 1111 再与 hash 做 & 运算的时候，各个位置的取值取决于 hash，如果不是2的整数次幂，必然会有的0的位，这样再进行 & 操作的时候就为 0了，会造成哈希冲突。注意：HashMap的tableSizeFor方法做了处理，能保证n永远都是2次幂

- 为什么负载因子是0.75？

> 负载因子过低，频繁扩容，扩容会重新哈希，性能下降;负载因子过高，容易浪费容量.（经验+概率）

- 为什么红黑树的阈值是8？

> 在 hash 函数设计合理的情况下，发生 hash 碰撞 8 次的几率为百万分之 6，概率说话。(泊松分布)

- 为什么退化链表的阈值6？

> 6是因为如果 hash 碰撞次数在 8 附近徘徊，会一直发生链表和红黑树的转化，为了预防这种情况的发生。

- hash

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

hash 函数是先拿到通过 key 的 hashcode，**是 32 位的 int 值**，然后让 **hashcode 的高 16 位和低 16 位进行异或操作**。这个也叫扰动函数，这么设计有二点原因：

- **一定要尽可能降低 hash 碰撞，越分散越好**；
- 算法一定要尽可能高效，因为这是高频操作, 因此采用位运算；