# 多态

## 定义

三要素：加黑的地方！

首先我觉得即**一个引用变量到底会指向哪个类的实例对象**，该**引用变量发出的方法调用到底是哪个类中实现的方法**，必须在由程序**运行期间**才能决定。强调在编译的时候，不知道该引用指向的是哪个对象的实例，包括调用哪个实例的方法，只有运行的时候，动态知道。

举个例子：

任何事物的多个姿态，多个形态。比如，你说一个猫在吃东西，同样的，你也能说一个动物在吃东西。

```java
public class Test {
    public static void main(String[] args){
        Animal animal = new Cat();
        animal.eat() // 猫也会吃饭
        // 你看到了一只猫，同样它也是动物
        // 比如有很多其他种类继承了动物哈，
        // 当编译期间的animal引用变量，到底指的哪个实例对象，（重要）（主语是引用变量）
        // 或者该引用调用的eat方法，到底是哪个实例对象的eat，编译期间恐怕不知道哦（主语是引用变量）
        // 只有运行期间，哦哦， 原来是猫的eat方法哇...
    }
}
```

## 表现形式

- **Java 的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但可具有不同的参数列表、返回值类型。调用方法时通过传递的参数类型来决定具体使用哪个方法**，这就是多态性。比如，`java lang` 的包很多工具类如 `String` 工具类，那么就有很多相同的名字，但是参数类型、数量和返回值等等不一样。

- **Java 的方法重写，是父类与子类之间的多态性，子类可继承父类中的方法，但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。重写的参数列表和返回类型均不可修改**。这也是多态性。比如 `JUC` 的 `AQS` 框架，凡事继承了 `AQS` 的那几个类，其中几个重要的方法，都被重写了，很多这样的情况。

## 底层

首先要说：首先当程序运行需要某个类时，类加载器会将相应的 `class` 文件载入到 JVM 中，并在方法区建立该类的类型信息（包括方法代码，类变量、成员变量以及**方法表**。（标黑的这个玩意）

面试官：方法表有啥？

我：方法表的结构如同字段表一样，依次包括了**访问标志、名称索引、描述符索引、属性表集合**几项。

接着回答：**方法表是实现动态调用的核心。为了优化对象调用方法的速度，方法区的类型信息会增加一个指针，该指针指向记录该类方法的方法表，方法表中的每一个项都是对应方法的指针**。

到这里：就要分情况讨论了，一个是方法调用，一个是接口

### 方法调用

```java
class Person {
    // 重写object的toString
    public String toString(){
        return "I'm a person.";
    }
    public void eat(){}
    public void speak(){}

}

class Boy extends Person{
    // 重写object的toString
    public String toString(){
        return "I'm a boy";
    }
    // 继承Person的speak
    public void speak(){}
    // 自己实现的自定义方法
    public void fight(){}
}

class Girl extends Person{
    // 重写object的toString
    public String toString(){
        return "I'm a girl";
    }
    // 继承Person的speak
    public void speak(){}
    // 自己实现的自定义方法
    public void sing(){}
}
```

![多态的底层原理-5jdak6](http://imgs.dreamcat.ink/uPic/%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-ioAt9U.png)

这张图的指向：你可以根据颜色对应上，注意方法表条目指向的具体的**方法地址**。其次注意蓝色部分其继承自于 `Person` 的方法 `eat()` 和 `speak()` 分别指向 **Person 的方法实现和本身的实现**。如果子类改写了父类的方法，那么子类和父类的那些**同名的方法共享一个方法表项**。因此，**所有继承父类的子类的方法表中，其父类所定义的方法的偏移量也总是一个定值**。`Person` 或 `Object` 中的任意一个方法，在它们的方法表和其子类 Girl 和 Boy 的方法表中的位置 (index) 是一样的。这样 JVM 在调用实例方法其实只需要指定调用方法表中的第几个方法即可。

调用过程：

1. 在常量池里找到方法调用的**符号引用**（肯定先看到 `Person` 定义引用类型）
2. 查看 `Person` 的方法表，得到 `speak` 方法在该**方法表的偏移量**（假设为 15），这样就得到该方法的直接引用。
3. 根据 `this`（invoker this 字节码）指针得到**具体的对象**（即 `girl` 所指向的位于堆中的对象）。
4. 根据对象得到该对象对应的方法表，根据偏移量 15 查看**有无重写（override）该方法**，如果重写，则可以直接调用（`Girl` 的方法表的 `speak` 项指向自身的方法而非父类）；如果没有重写，则需要拿到按照继承关系从下往上的基类（这里是 Person 类）的方法表，同样按照这个偏移量 15 查看有无该方法。

### 接口调用

一个类可以实现多个接口，那么就像多继承一样，这样的话，在方法表中的索引就会不一样，所以 `Java` 对于接口方法的调用是采用**搜索方法表**的方式。

## 初始化顺序

有这样的两个类：`Person` 和 `Student`

Person:

```java
class Person{
    // 静态代码块
    static {
        System.out.println("Person 静态方法");
    }
    // 代码块
    {
        System.out.println("Person 代码块");
    }
    // 构造方法
    Person(){
        System.out.println("Person 构造方法");
    }
}
```

Student:

```java
class Student extends Person{
    // 静态代码块
    static {
        System.out.println("Student 静态方法");
    }
    // 代码块
    {
        System.out.println("Student 代码块");
    }
    // 构造方法
    Student(){
        System.out.println("Student 构造方法");
    }
}
```

测试

```java
public class Main {
    public static void main(String[] args) {
        Student student = new Student();
    }
}

// result:

Person 静态方法
Student 静态方法
Person 代码块
Person 构造方法
Student 代码块
Student 构造方法
```

解释：还不是因为类加载器的双亲委派哈， 先走类方法，也就是说 static 属于类，所以先调用**Person static -> Student static**，接着走对象的初始化，那么对象初始化了，还是先走父类的初始化了，所以**Perosn {} -> Person(){}**，最后走子类的初始化**Student {} -> Student(){}**
