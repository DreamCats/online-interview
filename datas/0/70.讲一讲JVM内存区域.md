# JVM 内存区域

> JVM 这一块，经常还是经常被问到的

面试官：讲一讲 JVM 内存区域

我：行，先放两张图

![JVM内存模型-1.8之前-NFvh0E](https://cdn.jsdelivr.net/gh/DreamCats/imgs@main/uPic/JVM内存模型-1.8之前-NFvh0E.png)

![JVM内存模型-1.8-JjjMHV](https://cdn.jsdelivr.net/gh/DreamCats/imgs@main/uPic/JVM内存模型-1.8-JjjMHV.png)

总体来说，粗略的分为**堆和栈**，那么**栈是线程私有的**，而**堆是线程共享的**。那么**栈**又问分为**程序计数器**，**虚拟机栈**，**本地方法栈**。堆稍后再说，当然还有**方法区**，稍后单独说。

## 程序计数器

- **字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制**，如：顺序执行、选择、循环、异常处理。
- 在多线程的情况下，**程序计数器用于记录当前线程执行的位置**，**从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了**。
- **程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域**，它的生命周期随着线程的创建而创建，随着线程的结束而死亡

## 虚拟机栈

- 说白了，通俗的讲，主要是**对象中的方法产生的各种"材料"**。
- 因此，虚拟机栈存放的是**局部变量表**、**操作数栈**、**动态链接**、**方法出口**。
- 局部变量表存 8**大基本数据类型以及引用类型**。
- 当然，栈也会非常 error：
  - StackOverFlowError： 若 **Java 虚拟机栈的内存大小不允许动态扩展**，**那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候**，就抛出 StackOverFlowError 异常。
  - OutOfMemoryError：若 **Java 虚拟机栈的内存大小允许动态扩展**，**且当线程请求栈时内存用完了**，**无法再动态扩展了**，此时抛出 OutOfMemoryError 异常。

## 本地方法栈

虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而**本地方法栈则为虚拟机使用到的 Native 方法服务**，JDK 源码中很多本地方法哦。

## 方法区

这里单独说一下**方法区**：

**方法区与 Java 堆一样，是各个线程共享的内存区域**，它用于存储已被虚拟机加载的**类信息**、**常量**、**静态变量**、即时编译器编译后的代码等数据。不过随着版本的变化，会发生变化。

- 1.6:运行时常量池在 Perm Gen 区(也就是方法区)中；字符串常量池在**运行时常量池**中。
- 1.7:运行时常量池依然在 Perm Gen 区(也就是方法区)中在 JDK7 版本中，永久代的转移工作就已经开始了，将譬如**符号引用转移到了 native heap**；**字面量转移到了 java heap**；**类的静态变量转移到了 java heap**。但是运行时常量池依然还存在，只是很多内容被转移，其只存着这些被转移的引用；字符串常量池被分配到了**Java 堆的主要部分**。也就是字符串常量池从运行时常量池分离出来了。
- 1.8:JVM 已经将**运行时常量池从方法区中移了出来**，在**Java 堆（Heap）中开辟了一块区域存放运行时常量池**。同时永久代被移除，**以元空间代替**。**元空间并不在虚拟机中，而是使用本地内存**；**字符串常量池存在于 Java 堆中**。

方法区，依然会发生 error，因为在之前的版本中，**当一个类启动的时候，也会加载很多 class 文件**，那么也会充满整个方法区，当满的时候，也会 error 的，当然，在以前的版本中，字符串常量池在方法区中，而**使用 String.intern()方法，依然会占满空间并 error**。

## 直接内存

**直接内存**并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现（如**DirectByteBuffer**）。本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

## 堆

**堆**：此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。

- 分为四区，分别为 eden 区、s0("From)区、s1("To")和 tentired
- 在初始阶段，新创建的对象被分配到 Eden 区，survivor 的两块空间都为空。
- 当 Eden 区满了的时候，minor GC 触发
- 经过扫描与标记，存活的对象被复制到 S0，不存活的对象被回收
- 在下一次的 Minor GC 中，Eden 区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到 survivor 区。然而在 survivor 区，S0 的所有的数据都被复制到 S1，需要注意的是，在上次 minor GC 过程中移动到 S0 中的相同存活的对象在复制到 S1 后其年龄要加 1。此时 Eden 区 S0 区被清空，所有存活的数据都复制到了 S1 区，并且 S1 区存在着年龄不一样的对象（重点）
- 再下一次 MinorGC 则重复这个过程，这一次 survivor 的两个区对换，存活的对象被复制到 S0，存活的对象年龄加 1，Eden 区和另一个 survivor 区被清空。
