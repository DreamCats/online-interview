# 慢查询优化

面试官：慢查询优化

我：我试试

打开慢查询日志

1. 先运行看看是否真的很慢，注意设置 SQL_NO_CACHE
2. where 条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的 where 都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高
3. explain 查看执行计划，是否与 1 预期一致（从锁定记录较少的表开始查询）
4. order by limit 形式的 sql 语句让排序的表优先查（这里要注意如果数据量大，要注意了）
5. 了解业务方使用场景
6. 加索引时参照建索引的几大原则
7. 观察结果，不符合预期继续从 0 分析

咱们知道，使用 limit 分页查询，offset 越大，性能越差，比如：

```sql
-- 以真实的生产环境的6万条数据的一张表为例，比较一下优化前后的查询耗时：
-- 传统limit，文件扫描
select * from table order by id limit 50000,2;
受影响的行: 0
时间:  0.171s

-- 子查询方式，索引扫描
select * from table
where id >= (select id from table order by id limit 50000 , 1)
limit 2;
受影响的行: 0
时间: 0.035s

-- JOIN分页方式
select * from table as t1
join (select id from table order by id limit 50000, 1) as t2
where t1.id <= t2.id order by t1.id limit 2;
受影响的行: 0
时间: 0.036s
```

原因：因为 MySQL 并非是跳过偏移量直接去取后面的数据，而是先把偏移量+要取的条数，然后再把前面偏移量这一段的数据抛弃掉再返回的。比如上面的(50000，2)，每次取 2 条，还要经过回表，发现不是想要的，舍弃。那肯定非常耗时间，而通过子查询通过 id 索引，只查询 id，使用到了 innodb 的索引覆盖, 在内存缓冲区中进行检索,没有回表查询. 然后再用 id >= 条件,进一步的缩小查询范围.这样就大大提高了效率。

而 MyISAM，是直接索引是分离的，通过索引文件查到的数据记录地址，不需要回表，直接对应数据记录，效率也很高。
