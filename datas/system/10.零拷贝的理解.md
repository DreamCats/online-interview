# 零拷贝的理解

> 孤身独影，并非因为我被人遗弃，而是因为我找不到想要寻找的东西。

> 学习 epoll 的时候，提到了一个词语：零拷贝。那么今天就来讲讲零拷贝的前世今生。

## 背景

零拷贝（Zero-Copy）是一种 **I/O** 操作优化技术，可以快速高效地**将数据从文件系统移动到网络接口**，而不需要将其从内核空间复制到用户空间。

那么，很想知道传统的 I/O 操作是如何实现的？有什么样的性能缺陷呢？

假如服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。

传统 I/O 的工作方式是，**数据读取和写入是从用户空间到内核空间来回复制**，而内核空间的**数据是通过操作系统层面的 I/O 接口从磁盘读取或写入**。

代码示例，一般需要两个系统调用：

```c
read(file, tmp_buf, len);
write(socket, tmp_buf, len);
```

我们以图展示一下流程：

![](https://imgs.heiye.site/byte/1645611907735.png)

从图流程看，期间一共发生了**4 次用户态与内核态的上下文切换**，因为发生了**两次系统调用**，一次是 read() , 一次是 write()。

注意：上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被**累积和放大**，从而影响系统的性能。

再者，期间发生了**4 次数据拷贝**，其中两次是**DMA 的拷贝**，另外两次则是**CPU 拷贝**，接下来说一下这个过程：

- **第一次拷贝**：把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。
- **第二次拷贝**：把**内核缓冲区的数据拷贝到用户的缓冲区**里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。
- **第三次拷贝**：把刚才拷贝到用户的缓冲区里的数据，**再拷贝到内核的 socket 的缓冲区里**，这个过程依然还是由 CPU 搬运的。
- **第四次拷贝**：把内核的 socket 缓冲区里的数据，**拷贝到网卡的缓冲区**里，这个过程又是由 DMA 搬运的。

仔细一看，这种简单又传统的文件传输方式，存在冗余的上下文切换和数据拷贝，如果频繁的进行文件传输，那么会导致系统性能下降。

所以，**要想提高文件传输的性能，就需要减少上下文切换和数据拷贝的次数**。

## 零拷贝

零拷贝的技术有 mmap+write、sendfile 和 splice 等几种方式。

简单提一下虚拟内存：

所有现代操作系统都使用虚拟内存，使用虚拟地址取代物理地址，主要有以下几点好处：

- 多个虚拟内存可以指向同一个物理地址。
- 虚拟内存空间可以远远大于物理内存空间。

利用上述的第一条特性可以优化，可以把内核空间和用户空间的虚拟地址映射到同一个物理地址，这样在 I/O 操作时就不需要来回复制了。

### mmap/write 方式

使用 mmap/write 方式替换原来的传统 I/O 方式，就是利用了虚拟内存的特性。下图展示了 mmap/write 原理：

![](https://imgs.heiye.site/byte/1645612244780.png)

整个流程的核心区别就是，把数据读取到内核缓冲区后，应用程序进行写入操作时，**直接把内核的 Read Buffer 的数据复制到 Socket Buffer 以便写入**，这次内核之间的复制也是需要 CPU 的参与的。

上述流程就是少了一个 CPU COPY，提升了 I/O 的速度。不过发现上下文的切换还是 4 次并没有减少，这是因为还是要应用程序发起 write 操作。

那你就要想了，能不能减少一些上下文切换呢？，此时可能需要 sendfile 方式来替换 mmap/write 方式。

### sendfile

sendfile 方式将 mmap write 两个系统调用替换为 sendfile，这样就减少了上下文切换，因为少了一个应用程序发起 write 操作，直接发起 sendfile 操作。

![](https://imgs.heiye.site/byte/1645618466156.png)

sendfile 方式只有三次数据复制（其中只有一次 CPU COPY）以及 2 次上下文切换。

那继续思考，能不能继续优化呢？把 cpu copy 给从这个世界上消失掉，于是使用 scatter/gather 的 sendfile 方式了。

### scatter/gather

其原理就是**在内核空间 Read BUffer 和 Socket Buffer 不做数据复制，而是将 Read Buffer 的内存地址、偏移量记录到相应的 Socket Buffer 中，这样就不需要复制**。其本质和虚拟内存的解决方法思路一致，就是内存地址的记录。

![](https://imgs.heiye.site/byte/1645618540842.png)

scatter/gather 的 sendfile 只有两次数据复制（都是 DMA COPY）及 2 次上下文切换。

## 总结

无论是传统的 I/O 方式，还是引入了零拷贝之后，2 次 DMA copy 是都少不了的。因为两次 DMA 都是依赖硬件完成的。所以，所谓的零拷贝，都是为了减少 CPU copy 及减少了上下文的切换。

![](https://imgs.heiye.site/byte/1645618647158.png)

## 参考

- [https://juejin.cn/post/6995519558475841550](https://juejin.cn/post/6995519558475841550)
