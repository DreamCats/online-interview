
## paxos算法
> 要讲这个算法，还要先扯背景：在常见的分布式系统中，总会发生诸如机器宕机或网络异常（等情况。Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。

> 其实在整个提议和投票过程当中，主要的角色就是“提议者”和“接受者”

该算法大致流程：其实分为两个阶段

1. 因为存在多个“提议者”Proposer，如果都提意见，那么“接受者”Acceptor不就炸掉了嘛？到底接受谁啊？所以，要先明确哪个“提议者”是领袖，最厉害的那个，先把这个给挑出来。尽早的让意见统一，并且早点形成多数派。
2. 由上阶段选出的意见领袖提出提议，“接受者”反馈意见。如果多数“接受者”接受了一个提议，那么这个提议就通过了。

[例子](https://ocavue.com/paxos.html#%E8%8A%82%E7%82%B9%E6%95%85%E9%9A%9C%E7%9A%84%E4%BE%8B%E5%AD%90)

## ZAB
- ZAB协议包括两种基本的模式：**崩溃恢复**和**消息广播**。
- 当整个 Zookeeper 集群刚刚启动或**者Leader服务器宕机**、**重启**或者网络故障导致**少于过半的服务器与 Leader 服务器保持正常通信**时，所有服务器进入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务器开始与新的 Leader 服务器进行数据同步。
- 当集群中超过**半数机器与该 Leader 服务器完成数据同步**之后，退出恢复模式进入消息广播模式，Leader 服务器开始接收客户端的事务请求生成事物提案来进行事务请求处理。

## zk的leader选举算法和流程
目前有5台服务器，每台服务器均没有数据，它们的编号分别是1,2,3,4,5,按编号依次启动，它们的选择举过程如下：

1. 服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于Looking。
2. 服务器2启动，给自己投票，同时与之前启动的服务器1交换结果，由于服务器2的编号大所以服务器2胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是LOOKING。
3. 服务器3启动，给自己投票，同时与之前启动的服务器1,2交换信息，由于服务器3的编号最大所以服务器3胜出，此时投票数正好大于半数，所以服务器3成为leader，服务器1,2成为follower。
4. 服务器4启动，给自己投票，同时与之前启动的服务器1,2,3交换信息，尽管服务器4的编号大，但之前服务器3已经胜出，所以服务器4只能成为follower。
5. 服务器5启动，后面的逻辑同服务器4成为follower。

[https://www.cnblogs.com/wuzhenzhao/p/9983231.html](https://www.cnblogs.com/wuzhenzhao/p/9983231.html)


## raft

[https://zhuanlan.zhihu.com/p/66441389](https://zhuanlan.zhihu.com/p/66441389)



## 分布式一致性哈希

[https://zhuanlan.zhihu.com/p/24440059](https://zhuanlan.zhihu.com/p/24440059)