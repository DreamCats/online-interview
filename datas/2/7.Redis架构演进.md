# Redis 架构演进-带着问题找答案

## 背景

> 起初，我仅仅是想学习一下 Redis 的单 Reactor 模型而已，没想到看到了一篇很有意思的文章，带着问题逐渐知道 Redis 的演变架构。

怎么说，咱也用过 Redis，咱也就当 MySQL 撑不住的时候才会想到 Redis 的好（缓存），但从来没有认真思考他为什么这么强悍，能让所有的三高项目离不开他的伟大之处。那 Redis 到底是如何稳定、高性能地提供服务的？不妨我们动脑思考思考。

- 我使用 Redis 的场景很简单，只使用单机版 Redis 会有什么问题吗？
- 如果我的 Redis 故障宕机了，数据丢失了怎么办？如何才能保证我们的业务应用不受到影响？
- 为什么需要主从集群？究竟出现了什么问题，才能让我们采用主从集群？
- 什么事分片集群？什么场景下需要分片集群？

简单看过一些书籍-《Redis 的设计与实现》，想必大家都有所耳闻，但我们并没有真正的思考为什么需要**数据持久化、主从复制、哨兵**这些概念，这些又有什么区别和联系呢？

![](https://imgs.heiye.site/byte/1644820704900.png)

## 单机版 Redis

首先，我们从最简单的场景开始。

假设我们现在有一个业务也用，需要依然怒 Redis 来提高应用的性能，此时可以选择部署一个单机版的 Redis 来使用，就像这样：

![](https://imgs.heiye.site/byte/1644821220880.png)

从图中可以看到此架构非常简单，仅仅是将 Redis 当做缓存来使用，从 MySQL 中查询数据，然后写入到 Redis 中，之后业务应用再从 Redis 中读取这些数据，由于 Redis 的所有数据存在内存中，因此速度极快。

这样的场景可是业务体量不大，此架构模型基本可以满足咱们的需求，是不是超级简单？

好景不长，随着时间的推移，业务体量逐渐发展起来了，Redis 中存储的数据也越来越多，当时，此时业务应用对 Redis 的依赖也越来越重。

但是，倘若有一天，Redis 因为某些原因宕机了，这时业务流量，都会请求到后端 MySQL 上，这会导致 MySQL 的压力剧增，**缓存雪崩**，严重的话会压垮 MySQL。

这时，你的方案可能是：赶紧重启 Redis，让它可以继续提供服务。

但是，因为之前 Redis 中的数据都在内存中，尽管你现在把 Redis 重启了，之前的数据也都丢失了。

重启后的 Redis 虽然可以正常工作，但是由于 Redis 中没有任何数据，业务流量还是都会请求到后端 MySQL 上，MySQL 的压力还是很大。

怎么办？

既然 Redis 只把数据存储在内存中，那是否可以把**这些数据也写一份到磁盘上**呢？

如果采用这种方式，当 Redis 重启时，我们把磁盘中的数据快速恢复到内存中，这样它就可以继续正常提供服务了。

是的，这是一个很好的解决方案，这个把内存数据写到磁盘上的过程，就是「数据持久化」。

## 数据持久化：有备无患

现在，设想的 Redis 数据持久化是这样的：

![](https://imgs.heiye.site/byte/1644822433771.png)

但是，数据持久化具体应该怎么做呢？

最容易想到的一个方案是：Redis 每一次执行写操作，除了写内存之外，同时也写一份到磁盘上，就像这样：

![](https://imgs.heiye.site/byte/1644822500648.png)

确实，这是最简单直接的方案。

但，仔细想一下，这个方案存在一个问题：客户端的每次写操作，即需要**写内存，又需要写磁盘**，而写磁盘的耗时相对于写内存来说，还要是要**慢**很多，这百分百会影响到 Redis 的性能。

如何解决这个问题呢？

我们可以这样优化：Redis **写内存由主线程**来做，写内存完成后就给客户端返回结果，然后 Redis 用**另一个线程去写磁盘**，这样就可以避免主线程写磁盘对性能的影响。

这确实是一个好方案。除此之外，我们可以换个角度，思考一下还有什么方式可以持久化数据？

这时你就要结合 Redis 的使用场景来考虑了。

回忆一下，我们在使用 Redis 时，通常把它用作什么场景？

是的，缓存。

把 Redis 当做缓存来用，意味着尽管 Redis 中没有保存全量数据，对于不在缓存中的数据，我们的业务应用依旧可以通过查询后端数据库得到结果，只不过查询后端数据的速度会慢一点而已，但对业务结果其实是没有影响的。

基于这个特点，我们的 Redis 数据持久化还可以用「数据快照」的方式来做。

那什么是数据快照呢？

简单来讲，你可以这么理解：

> 1. 你把 Redis 想象成一个水杯，向 Redis 写入数据，就相当于往这个杯子里倒水。
> 2. 此时你拿一个相机给这个水杯拍一张照片，拍照的这一瞬间，照片中记录到这个水杯中水的容量，就是水杯的数据快照。

![](https://imgs.heiye.site/byte/1644822934826.png)

相当于，Redis 的数据快照，是记录某一时刻下 Redis 中的数据，然后只需要把这个数据快照写道磁盘上就可。

它的优势在于，只在需要持久化时，把数据「一次性」写入磁盘，其它时间都不需要操作磁盘。

基于这个方案，我们可以定时给 Redis 做数据快照，把数据持久化到磁盘上。

![](https://imgs.heiye.site/byte/1644823233667.png)

其实，上面说的这些持久化方案，就是 Redis 的「RDB」和「AOF」：

- RDB：只持久化**某一时刻的数据快照到磁盘上**（创建一个子进程来做）
- AOF：**每一次写操作都持久到磁盘**（主线程写内存，根据策略可以配置由主线程还是子线程进行数据持久化）
  它们的区别除了上面讲到的，还有以下特点：

> 1. RDB 采用二进制 + 数据压缩的方式写磁盘，这样文件体积小，数据恢复速度也快。
> 2. AOF 记录的是每一次写命令，数据最全，但文件体积大，数据恢复速度慢。

如果让你来选择持久化方案，你可以这样选择：

> 1. 如果你的业务对于数据丢失不敏感，采用 RDB 方案持久化数据。
> 2. 如果你的业务对数据完整性要求比较高，采用 AOF 方案持久化数据。

假设你的业务对 Redis 数据完整性要求比较高，选择了 AOF 方案，那此时你又会遇到这些问题：

> 1. AOF 记录每一次写操作，随着时间增长，AOF 文件体积会越来越大。
> 2. 这么大的 AOF 文件，在数据恢复时变得非常慢。

这怎么办？数据完整性要求变高了，恢复数据也变困难了？有没有什么方法，可以缩小文件体积？提升恢复速度呢？

我们继续来分析 AOF 的特点。

由于 AOF 文件中记录的都是每一次写操作，但对于同一个 key 可能会发生多次修改，我们只保留最后一次被修改的值，是不是也可以？

是的，这就是我们经常听到的「AOF rewrite」，你也可以把它理解为 AOF 「瘦身」。

我们可以对 AOF 文件定时 rewrite，避免这个文件体积持续膨胀，这样在恢复时就可以缩短恢复时间了。

![](https://imgs.heiye.site/byte/1644823775665.png)

再进一步思考一下，还有没有办法继续缩小 AOF 文件？

回顾一下前面讲到的，RDB 和 AOF 各自的特点：

> 1、RDB 以二进制 + 数据压缩方式存储，文件体积小。
> 2、AOF 记录每一次写命令，数据最全。

我们可否利用它们各自的优势呢？

当然可以，这就是 Redis 的「混合持久化」。

具体来说，当 AOF rewrite 时，Redis 先以 RDB 格式在 AOF 文件中写入一个数据快照，再把在这期间产生的每一个写命令，追加到 AOF 文件中。因为 RDB 是二进制压缩写入的，这样 AOF 文件体积就变得更小了。

![](https://imgs.heiye.site/byte/1644825232740.png)

此时，你在使用 AOF 文件恢复数据时，这个恢复时间就会更短了！

注意：Redis 4.0 以上版本才支持混合持久化。

这么一番优化，你的 Redis 再也不用担心实例宕机了，当发生宕机时，你就可以用持久化文件快速恢复 Redis 中的数据。

但这样就没问题了吗？

仔细想一下，虽然我们已经把持久化的文件优化到最小了，但在恢复数据时依旧是需要时间的，在这期间你的业务应用还是会受到影响，这怎么办？

我们来分析有没有更好的方案。

一个实例宕机，只能用恢复数据来解决，那我们是否可以部署多个 Redis 实例，然后让这些实例数据保持实时同步，这样当一个实例宕机时，我们在剩下的实例中选择一个继续提供服务就好了。

没错，这个方案就是接下来要讲的「主从复制：多副本」。

## 主从复制：多副本

此时，你可以部署多个 Redis 实例，架构模型就变成了这样：

![](https://imgs.heiye.site/byte/1644825569568.png)

我们这里把实时读写的节点叫做 master，另一个实时同步数据的节点叫做 slave。

采用多副本的方案，它的优势是：

1. 缩短不可用时间：master 发生宕机，我们可以手动把 slave 提升为 master 继续提供服务。
2. 提升读性能：让 slave 分担一部分读请求，提升应用的整体性能。

![](https://imgs.heiye.site/byte/1644825719747.png)

这个方案不错，不仅节省了数据恢复的时间，还能提升性能，那它有什么问题吗？

你可以思考一下。

其实，它的问题在于：当 master 宕机时，我们需要「手动」把 slave 提升为 master，这个过程也是需要花费时间的。

虽然比恢复数据要快得多，但还是需要人工介入处理。一旦需要人工介入，就必须要算上人的反应时间、操作时间，所以，在这期间你的业务应用依旧会受到影响。

怎么解决这个问题？我们是否可以把这个切换的过程，变成自动化呢？

对于这种情况，我们需要一个「故障自动切换」机制，这就是我们经常听到的「哨兵」所具备的能力。

## 哨兵：故障自动切换

现在，我们可以引入一个「观察者」，让这个观察者去实时监测 master 的健康状态，这个观察者就是「哨兵」。

具体如何做？

> 1. 哨兵每隔一段时间询问 master 是否正常
> 2. master 正常回复，表示状态正常，回复超时表示异常
> 3. 哨兵发现异常，发起主从切换

![](https://imgs.heiye.site/byte/1644826007997.png)

有了这个方案，就不需要人去介入处理了，一切就变得自动化了，是不是很爽？

但这里还有一个问题，如果 master 状态正常，但这个哨兵在询问 master 时，它们之间的网络发生了问题，那这个哨兵可能会误判。

这个问题怎么解决？

答案是，我们可以部署多个哨兵，让它们分布在不同的机器上，它们一起监测 master 的状态，流程就变成了这样：（过半机制...）

1、哨兵每隔一段时间询问 master 是否正常。

2、master 正常回复，表示状态正常，回复超时表示异常。

3、一旦有一个哨兵判定 master 异常（不管是否是网络问题），就询问其它哨兵，如果多个哨兵（设置一个阈值）都认为 master 异常了，这才判定 master 确实发生了故障。

4、多个哨兵经过协商后，判定 master 故障，则发起主从切换。

所以，我们用多个哨兵互相协商来判定 master 的状态，这样一来，就可以大大降低误判的概率。

哨兵协商判定 master 异常后，这里还有一个问题：由哪个哨兵来发起主从切换呢？

答案是，选出一个哨兵「领导者」，由这个领导者进行主从切换。

问题又来了，这个领导者怎么选？

想象一下，在现实生活中，选举是怎么做的？

是的，投票。

在选举哨兵领导者时，我们可以制定这样一个选举规则：

> 1. 每个哨兵都询问其它哨兵，请求对方为自己投票。
> 2. 每个哨兵只投票给第一个请求投票的哨兵，且只能投票一次。
> 3. 首先拿到超过半数投票的哨兵，当选为领导者，发起主从切换。

其实，这个选举的过程就是我们经常听到的：**分布式系统领域中的「共识算法」**。

**什么是共识算法（分布式一致性协议）？**

我们在多个机器部署哨兵，它们需要共同协作完成一项任务，所以它们就组成了一个「分布式系统」。

在分布式系统领域，多个节点如何就一个问题达成共识的算法，就叫共识算法。

在这个场景下，多个哨兵共同协商，选举出一个都认可的领导者，就是使用共识算法完成的。

这个算法还规定节点的数量必须是奇数个，这样可以保证系统中即使有节点发生了故障，剩余超过「半数」的节点状态正常，依旧可以提供正确的结果，也就是说，这个算法还兼容了存在故障节点的情况。

> 共识算法在分布式系统领域有很多，例如 Paxos、Raft，哨兵选举领导者这个场景，使用的是 Raft 共识算法，因为它足够简单，且易于实现。

现在，我们用多个哨兵共同监测 Redis 的状态，这样一来，就可以避免误判的问题了，架构模型就变成了这样：

![](https://imgs.heiye.site/byte/1644826277704.png)

好了，到这里我们先小结一下。

你的 Redis 从最简单的单机版，经过数据持久化、主从多副本、哨兵集群，这一路优化下来，你的 Redis 不管是性能还是稳定性，都越来越高，就算节点发生故障，也不用担心了。

你的 Redis 以这样的架构模式部署，基本上就可以稳定运行很长时间了。

...

随着时间的发展，你的业务体量开始迎来了爆炸性增长，此时你的架构模型，还能够承担这么大的流量吗？

我们一起来分析一下：

> 1. 稳定性：Redis 故障宕机，我们有哨兵 + 副本，可以自动完成主从切换
> 2. 读性能：读请求量增长，我们可以再部署多个 slave，读写分离，分担读压力
> 3. 写性能：写请求量增长，但我们只有一个 master 实例，这个实例达到瓶颈怎么办？

看到了么，当你的写请求量越来越大时，一个 master 实例可能就无法承担这么大的写流量了。

要想完美解决这个问题，此时你就需要考虑使用「分片集群」了。

## 分片集群：横向扩展

什么是「分片集群」？

简单来讲，一个实例扛不住写压力，那我们是否可以部署多个实例，然后把这些实例按照一定规则组织起来，把它们当成一个整体，对外提供服务，这样不就可以解决集中写一个实例的瓶颈问题吗？

所以，现在的架构模型就变成了这样：

![](https://imgs.heiye.site/byte/1644826575708.png)

现在问题又来了，这么多实例如何组织呢？

我们制定规则如下：

> 1. 每个节点各自存储一部分数据，所有节点数据之和才是全量数据。
> 2. 制定一个路由规则，对于不同的 key，把它路由到固定一个实例上进行读写。

而分片集群根据路由规则所在位置的不同，还可以分为两大类：

> 1. 客户端分片
> 2. 服务端分片

客户端分片指的是，key 的路由规则放在客户端来做，就是下面这样：

![](https://imgs.heiye.site/byte/1644826792997.png)

这个方案的缺点是，客户端需要维护这个路由规则，也就是说，你需要把路由规则写到你的业务代码中。

如何做到不把路由规则耦合在业务代码中呢？

你可以这样优化，把这个路由规则封装成一个模块，当需要使用时，集成这个模块就可以了。

这就是 Redis Cluster 的采用的方案。

![](https://imgs.heiye.site/byte/1644826913871.png)

当然，Redis Cluster 内置了哨兵逻辑，无需再部署哨兵。

当你使用 Redis Cluster 时，你的业务应用需要使用配套的 Redis SDK，这个 SDK 内就集成好了路由规则，不需要你自己编写了。

再来看服务端分片。

这种方案指的是，路由规则不放在客户端来做，而是在客户端和服务端之间增加一个「中间代理层」，这个代理就是我们经常听到的 Proxy。

而数据的路由规则，就放在这个 Proxy 层来维护。

这样一来，你就无需关心服务端有多少个 Redis 节点了，只需要和这个 Proxy 交互即可。

Proxy 会把你的请求根据路由规则，转发到对应的 Redis 节点上，而且，当集群实例不足以支撑更大的流量请求时，还可以横向扩容，添加新的 Redis 实例提升性能，这一切对于你的客户端来说，都是透明无感知的。

业界开源的 Redis 分片集群方案，例如 Twemproxy、Codis 就是采用的这种方案。

![](https://imgs.heiye.site/byte/1644827208691.png)

至此，当你使用分片集群后，对于未来更大的流量压力，都可以从容面对了！

思路清晰独特...

## 总结

此处省略...[滑稽]

## 参考

- [https://jishuin.proginn.com/p/763bfbd4d516](https://jishuin.proginn.com/p/763bfbd4d516)
